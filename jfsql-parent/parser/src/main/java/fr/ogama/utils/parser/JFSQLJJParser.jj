/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  STATIC = false; // (default true)  IGNORE_CASE = true;}PARSER_BEGIN(JFSQLJJParser)package fr.ogama.utils.parser;import fr.ogama.utils.parser.model.*;import java.util.Vector;import fr.ogama.utils.parser.model.get.*;import fr.ogama.utils.parser.model.get.expressions.logical.*;import fr.ogama.utils.parser.model.get.expressions.comparator.*;import java.io.DataInputStream;import java.io.FileInputStream;import fr.ogama.utils.parser.model.get.function.*;public class JFSQLJJParser{  public static void main(String args []) throws JFSQLParseException  {    try    {      JFSQLJJParser jfsqlParser = null;      if (args.length == 1)      {        jfsqlParser = new JFSQLJJParser(new DataInputStream(new FileInputStream(args [0])));        Vector v = jfsqlParser.JFSQLStatements();        for (int i = 0; i < v.size(); i++)        {          Statement st = (Statement) v.elementAt(i);          System.out.println(st.toString());        }      }      else      {        throw new JFSQLParseException("No argument has been specified");      }    }    catch (Exception e)    {      throw new JFSQLParseException(e.getMessage());    }  }}PARSER_END(JFSQLJJParser)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN :{  < K_GET : "GET" >| < K_DISTINCT : "DISTINCT" >| < K_IN : "IN" >| < K_DEEP : "DEEP" >| < K_HAVING : "HAVING" >| < K_SORT : "SORT" >| < K_BY : "BY" >| < K_OR : "OR" >| < K_AND : "AND" >| < K_NOT : "NOT" >| < K_LIKE : "LIKE" >| < K_BETWEEN : "BETWEEN" >| < K_MATCH : "MATCH" >| < K_INFINITY : "INFINITY" >| < K_AVG : "AVG" >| < K_MIN : "MIN" >| < K_MAX : "MAX" >| < K_SUM : "SUM" >| < K_COUNT : "COUNT" >| < K_SELECT : "SELECT" >| < K_ASCENDING : "ASCENDING" >| < K_DESCENDING : "DESCENDING" >| < K_ASDATESTRING : "ASDATESTRING" >| < K_ASDATE : "ASDATE" >
| < K_ASINTEGER : "ASINTEGER" >
| < K_ASLONG : "ASLONG" >
| < K_ASCONCAT : "CONCAT" >
| < K_ASEXTRACT : "EXTRACT" >
| < K_ASSTRING : "ASSTRING" >}TOKEN : /* Numeric Constants */{  < S_NUMBER :    < FLOAT >  | < FLOAT >    (      [ "e", "E" ] ([ "-", "+" ])? < FLOAT >    )? >| < #FLOAT :    < INTEGER >  | < INTEGER > ("." < INTEGER >)?  | "." < INTEGER >>| < #INTEGER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}SPECIAL_TOKEN :{  < LINE_COMMENT : "--" (~[ "\r", "\n" ])* >| < MULTI_LINE_COMMENT :    "/*" (~[ "*" ])* "*"    (      "*"    |      (        ~[ "*", "/" ] (~[ "*" ])* "*"      )    )*    "/" >}TOKEN :{  < S_IDENTIFIER :    (< LETTER >)+    (      < DIGIT >    | < LETTER >    | < SPECIAL_CHARS >    )* >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #SPECIAL_CHARS :    "$"  | "_" >| < S_BIND : ":" < S_IDENTIFIER > ("." < S_IDENTIFIER >)? >| < S_CHAR_LITERAL :    "'" (~[ "'" ])* "'"    (      "'" (~[ "'" ])* "'"    )* >| < S_QUOTED_IDENTIFIER : "\"" (~[ "\n", "\r", "\"" ])* "\"" >}Vector JFSQLStatements() :{  Vector v = new Vector();  Statement s;}{  (    s = JFSQLStatement()    {      if (s == null) return v;      else v.addElement(s);    }  )+  {    return v;  }}Statement JFSQLStatement() :{  Statement s = null;}{  (    s = getQuery()  | s = primaryExpression()  )  ";"  {    return s;  }}GetStatement getQuery() :{  GetStatement getStatement = new GetStatement();  GetClause getClause = new GetClause();  InClause inClause = new InClause();  HavingClause havingClause = null;  SortByClause sortByClause = null;}{  getClause = getClause() inClause = inClause() [ havingClause = havingClause() ] [ sortByClause = sortByClause() ]  {    getStatement.setGetClause(getClause);    getStatement.setInClause(inClause);    getStatement.setHavingClause(havingClause);    getStatement.setSortByClause(sortByClause);    return getStatement;  }}GetClause getClause() :{  GetClause getClause = new GetClause();  Expression property = null;  Token limit = null;  boolean distinct = false;}{  "GET" [ limit = < S_NUMBER > ]  [    "DISTINCT"    {      distinct = true;    }  ]  property = primaryExpression()  {    getClause.setLimit(limit != null ? limit.toString() : null);    getClause.setDistinct(distinct);    getClause.setProperty(property);    return getClause;  }}InClause inClause() :{  InClause inClause = new InClause();  Vector pathItems = new Vector();  PathItem pathItem;}{  "IN" "(" pathItem = pathItem()  {    pathItems.addElement(pathItem);  }  (    "," pathItem = pathItem()    {      pathItems.addElement(pathItem);    }  )*  ")"  {    inClause.setPathItems(pathItems);    return inClause;  }}HavingClause havingClause() :{  HavingClause havingClause = null;  Expression expression;}{  "HAVING" expression = expression()  {    if (expression != null)    {      havingClause = new HavingClause();      havingClause.setExpression(expression);    }    return havingClause;  }}SortByClause sortByClause() :{  SortByClause sortByClause = new SortByClause();  Token property;  boolean isAscending = true; // default value
}{  "SORT" "BY" property = < S_IDENTIFIER >  [    "ASCENDING"  | "DESCENDING"    {      isAscending = false;    }  ]  {    sortByClause.setProperty(property != null ? property.toString() : null);    sortByClause.setAscendingOrder(isAscending);    return sortByClause;  }}PathItem pathItem() :{  PathItem pathItem = new PathItem();  Token path = null;  GetStatement subGetStatement = null;  Token deep = null;}{  (    path = < S_CHAR_LITERAL >  | subGetStatement = subQuery()  )  [ "DEEP" deep = < S_NUMBER > ]  {    if (path != null)    {      pathItem.setPath(new Constant(path.toString().substring(1, path.toString().length() - 1), 3));    }    if (subGetStatement != null)    {      pathItem.setPath(subGetStatement);    }    pathItem.setDeep(deep != null ? deep.toString() : null);    return pathItem;  }}Expression expression() :{  Expression e1, e2;  ExpressionImpl e = null;  boolean single = true;}{  e1 = andExpression()  (    "OR" e2 = andExpression()    {      if (single)      {        e = new OrExpression("OR", e1);      }      single = false;      e.addOperand(e2);    }  )*  {    return (single ? e1 : e);  }}Expression andExpression() :{  Expression e1, e2;  ExpressionImpl e = null;  boolean single = true;}{  e1 = unaryLogicalExpression()  (    "AND" e2 = unaryLogicalExpression()    {      if (single)      {        e = new AndExpression("AND", e1);      }      single = false;      e.addOperand(e2);    }  )*  {    return (single ? e1 : e);  }}Expression unaryLogicalExpression() :{  Expression e;  ExpressionImpl not = null;}{  [    "NOT"    {      not = new NotExpression("NOT");    }  ]  e = relationalExpression()  {    if (not != null)    {      not.addOperand(e);    }    return not == null ? e : not;  }}Expression relationalExpression() :{  Expression e1, eleft;  ExpressionImpl eright = null;  Vector v;  boolean prior = false;
  boolean not = false;}{  /* Only after looking past "(", Expression() and "," we will know that
it is expression list */  (    LOOKAHEAD("(" simpleExpression() ",") //)
    "(" v = expressionList() ")"    {      eleft = new ExpressionImpl(",");      ((ExpressionImpl) eleft).setOperands(v);    }  |    (      e1 = simpleExpression()      {        if (prior) eleft = new ExpressionImpl("PRIOR", e1);        else eleft = e1;      }    )  ) //Closes parenthese opened before LOOKAHEAD
  /* Lookahead(2) is required because of NOT IN,NOT BETWEEN and NOT LIKE */  (    eright = relationalOperatorExpression()  | LOOKAHEAD(2)    (
      [
	    "NOT"
	    {
	      not = true;
	    }
	  ]      eright = inClauseExpression()    )  | LOOKAHEAD(2)    (
      [
	    "NOT"
	    {
	      not = true;
	    }
	  ]      eright = betweenClauseExpression()    )  | LOOKAHEAD(2)    (
      [
	    "NOT"
	    {
	      not = true;
	    }
	  ]      eright = likeClauseExpression()    )  | LOOKAHEAD(2)    (
      [
	    "NOT"
	    {
	      not = true;
	    }
	  ]      eright = matchClauseExpression()    )  )?  {    if (eright == null) return eleft;    Vector v2 = eright.getOperands();    if (v2 == null) v2 = new Vector(); //For IS NULL, which is unary!
    v2.insertElementAt(eleft, 0);    eright.setOperands(v2);
        return not ? new NotExpression("NOT", eright) : eright;  }}Vector expressionList() :{  Vector v = new Vector(8);  Expression e;}{  e = simpleExpressionOrPreparedCol()  {    v.addElement(e);  }  (    "," e = simpleExpressionOrPreparedCol()    {      v.addElement(e);    }  )*  {    return v;  }}ExpressionImpl relationalOperatorExpression() :{  ExpressionImpl e;  Expression e1, eright;  String op;  String unaryOp = null;}{  e = Relop()  (    (      "(" e1 = subQuery() ")"      {        if (unaryOp == null) eright = e1;        else eright = new ExpressionImpl(unaryOp, e1);      }    )  | e1 = simpleExpressionOrPreparedCol()    {      if (unaryOp == null) eright = e1;      else eright = new ExpressionImpl(unaryOp, e1);    }  )  {    e.addOperand(eright);    return e;  }}Expression simpleExpressionOrPreparedCol() :{  Expression e;}{  e = simpleExpression()  {    return e;  }| e = preparedCol()  {    return e;  } // For prepared columns ("?")
| e = subQuery()  {    return e;  }}// For prepared columns ("?")
Expression preparedCol() :{}{  "?"  {    return new ExpressionImpl("?");  } // For prepared columns ("?")
}ExpressionImpl inClauseExpression() :{  ExpressionImpl e;  GetStatement q = null;  Vector v = null;}{  "IN"  {    e = new In("IN");  }  "("  (    LOOKAHEAD(2)    v = expressionList()    {      e.setOperands(v);    }  | q = subQuery()    {      e.addOperand(q);    }  )  ")"  {    return e;  }}ExpressionImpl betweenClauseExpression() :{  ExpressionImpl e;  Expression e1, e2;}{  "BETWEEN" e1 = simpleExpressionOrPreparedCol() "AND" e2 = simpleExpressionOrPreparedCol()  {    e = new Between("BETWEEN", e1, e2);    return e;  }}ExpressionImpl likeClauseExpression() :{  Expression eright;  ExpressionImpl e;}{  "LIKE" eright = simpleExpressionOrPreparedCol()  {    e = new Like("LIKE", eright);    return e;  }}ExpressionImpl matchClauseExpression() :{  Expression eright;  ExpressionImpl e;}{  "MATCH" eright = simpleExpressionOrPreparedCol()  {    e = new Match("MATCH", eright);    return e;  }}Expression simpleExpression() :{  Token op;  Expression e1, e2;  ExpressionImpl e = null;}{  e1 = multiplicativeExpression()  (    (      op = "+"    | op = "-"    | op = "||"    )    e2 = multiplicativeExpression()    {      e = new ExpressionImpl(op.toString(), e1);      e.addOperand(e2);      e1 = e;    }  )*  {    return e1;  }}Expression multiplicativeExpression() :{  Token op;  Expression e1, e2;  ExpressionImpl e = null;}{  e1 = expotentExpression()  (    (      op = "*"    | op = "/"    )    e2 = expotentExpression()    {      e = new ExpressionImpl(op.toString(), e1);      e.addOperand(e2);      e1 = e;    }  )*  {    return e1;  }}Expression expotentExpression() :{  Token op;  Expression e1, e2;  ExpressionImpl e = null;  boolean single = true;}{  e1 = unaryExpression()  (    op = "**" e2 = unaryExpression()    {      if (single) e = new ExpressionImpl(op.toString(), e1);      single = false;      e.addOperand(e2);    }  )*  {    return (single ? e1 : e);  }}Expression unaryExpression() :{  Token op = null;  Expression e1, e;}{  [    op = "+"  | op = "-"  ]  e1 = primaryExpression()  {    if (op == null) e = e1;    else e = new ExpressionImpl(op.toString(), e1);    return e;  }}Expression primaryExpression() :{  Token t;  String s, s2, modifier = "";  Expression e;}{  LOOKAHEAD(outerJoinExpression())  s = outerJoinExpression()  {    return Constant.getProperty(s);  }| LOOKAHEAD(2)  e = functionCall()  {    return e;  }  /*
| LOOKAHEAD(<S_IDENTIFIER> "(") e = FunctionCall() { return e; }
*/| s = tableColumn()  {    return Constant.getProperty(s);  }| t = < S_NUMBER >  {    return new Constant(t.toString(), Constant.NUMBER);  }| t = < S_CHAR_LITERAL >  {    s = t.toString();    if (s.startsWith("\'")) s = s.substring(1);    if (s.endsWith("\'")) s = s.substring(0, s.length() - 1);    return new Constant(s, Constant.STRING);  }| t = < S_BIND >  {    return new Constant(t.toString(), Constant.STRING);  }| "(" e = expression() ")"  {    return e;  }}AbstractFunction aggregateFunc() :{  Token t;}{  t = "SUM"  {    return new Sum(t.toString());  }| t = "AVG"  {    return new Avg(t.toString());  }| t = "MAX"  {    return new Max(t.toString());  }| t = "MIN"  {    return new Min(t.toString());  }| t = "COUNT"  {    return new Count(t.toString());  }| t = "ASDATESTRING"  {    return new AsDateString(t.toString());  }| t = "ASDATE"  {    return new AsDate(t.toString());  }
| t = "ASSTRING"
  {
    return new AsString(t.toString());
  }
| t = "ASINTEGER"
  {
    return new AsInteger(t.toString());
  }
| t = "ASLONG"
  {
    return new AsLong(t.toString());
  }
| t = "CONCAT"
  {
    return new Concat(t.toString());
  }
| t = "EXTRACT"
  {
    return new Extract(t.toString());
  }}ExpressionImpl functionCall() :{  Token t;  String s = "";  ExpressionImpl e = null;  Vector parm = null;}{  (    t = < S_IDENTIFIER >    {      s = t.toString();    }  | e = aggregateFunc()  )  "(" [ parm = expressionList() ] ")"  {    if (e == null)    {      throw new JFSQLParseException("Undefined function " + s);    }    int nparm = Utils.isCustomFunction(e != null ? e.getOperator() : "");    if (nparm < 0) nparm = (Utils.isAggregate(e != null ? e.getOperator() : "") ? 1 : - 1);    if (nparm < 0) throw new JFSQLParseException("Undefined function : " + (e != null ? e.getOperator() : "null"));    if (nparm != Utils.VARIABLE_PLIST && nparm > 0)    {      if (parm == null || parm.size() != nparm) throw new JFSQLParseException("Function " + e != null ? e.getOperator() : "null" + " should have " + nparm + " parameter(s)");    }    e.setOperands(parm);    return e;  }}String outerJoinExpression() :{  String s = null;  String c = "";}{  // user.table.col
  s = objectName()  [    "." c = objectName()    {      s += "." + c;    }    [      "." c = objectName()      {        s += "." + c;      }    ]  ]  "(" "+" ")"  {    return s + "(+)";  }}GetStatement subQuery() :{  GetStatement q;}{  q = getQuery()  {    return q;  }}ExpressionImpl Relop() :{  Token op;}{  op = "="  {    return new Equal(op.toString());  }| op = "<>"  {    return new UnEqual(op.toString());  }| op = ">"  {    return new GreatherThan(op.toString());  }| op = ">="  {    return new GreatherThanOrEqual(op.toString());  }| op = "<"  {    return new LessThan(op.toString());  }| op = "<="  {    return new LessThanOrEqual(op.toString());  }}String tableColumn() :{  StringBuffer buf = new StringBuffer();  String s;}{  // user.table.column
  s = objectName()  {    buf.append(s);  }  [    "." s = objectName()    {      buf.append("." + s);    }    [      "." s = objectName()      {        buf.append("." + s);      }    ]  ]  {    return buf.toString();  }}String objectName() :{  Token t;}{  t = < S_IDENTIFIER >  {    return t.toString();  }| t = < S_QUOTED_IDENTIFIER >  {    return t.toString();  }}
