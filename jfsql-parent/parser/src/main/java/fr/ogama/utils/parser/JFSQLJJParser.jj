/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  STATIC = false; // (default true)  IGNORE_CASE = true;}PARSER_BEGIN(JFSQLJJParser)package fr.ogama.utils.parser;import fr.ogama.utils.parser.model.*;import java.util.Vector;import fr.ogama.utils.parser.model.get.*;import java.io.DataInputStream;import java.io.FileInputStream;public class JFSQLJJParser{  public static void main(String args []) throws Exception  {    JFSQLJJParser jfsqlParser = null;    if (args.length == 1)    {      jfsqlParser = new JFSQLJJParser(new DataInputStream(new FileInputStream(args [0])));      Vector v = jfsqlParser.JFSQLStatements();      for (int i = 0; i < v.size(); i++)      {        Statement st = (Statement) v.elementAt(i);        System.out.println(st.toString());      }    }    else    {      throw new Exception("No argument has been specified");    }  }}PARSER_END(JFSQLJJParser)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN :{  < K_GET : "GET" >| < K_DISTINCT : "DISTINCT" >| < K_IN : "IN" >| < K_DEEP : "DEEP" >| < K_ : "HAVING" >| < K_SORT : "SORT" >| < K_BY : "BY" >| < K_OR : "OR" >| < K_AND : "AND" >| < K_NOT : "NOT" >| < K_LIKE : "LIKE" >| < K_BETWEEN : "BETWEEN" >| < K_MATCH : "MATCH" >| < K_INFINITY : "INFINITY" >| < K_AVG : "AVG" >| < K_MIN : "MIN" >| < K_MAX : "MAX" >| < K_SUM : "SUM" >| < K_COUNT : "COUNT" >| < K_PRIOR : "PRIOR" >| < K_ANY : "ANY" >| < K_NULL : "NULL" >| < K_ALL : "ALL" >| < K_EXISTS : "EXISTS" >| < K_SELECT : "SELECT" >| < K_ASCENDING : "ASCENDING" >| < K_DESCENDING : "DESCENDING" >}TOKEN : /* Numeric Constants */{  < S_NUMBER :    < FLOAT >  | < FLOAT >    (      [ "e", "E" ] ([ "-", "+" ])? < FLOAT >    )? >| < #FLOAT :    < INTEGER >  | < INTEGER > ("." < INTEGER >)?  | "." < INTEGER >>| < #INTEGER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}SPECIAL_TOKEN :{  < LINE_COMMENT : "--" (~[ "\r", "\n" ])* >| < MULTI_LINE_COMMENT :    "/*" (~[ "*" ])* "*"    (      "*"    |      (        ~[ "*", "/" ] (~[ "*" ])* "*"      )    )*    "/" >}TOKEN :{  < S_IDENTIFIER :    (< LETTER >)+    (      < DIGIT >    | < LETTER >    | < SPECIAL_CHARS >    )* >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #SPECIAL_CHARS :    "$"  | "_" >| < S_BIND : ":" < S_IDENTIFIER > ("." < S_IDENTIFIER >)? >| < S_CHAR_LITERAL :    "'" (~[ "'" ])* "'"    (      "'" (~[ "'" ])* "'"    )* >| < S_QUOTED_IDENTIFIER : "\"" (~[ "\n", "\r", "\"" ])* "\"" >}Vector JFSQLStatements() :{  Vector v = new Vector();  Statement s;}{  (    s = JFSQLStatement()    {      if (s == null) return v;      else v.addElement(s);    }  )+  {    return v;  }}Statement JFSQLStatement() :{  Statement s = null;}{  s = getQuery() ";"  {    return s;  }}GetStatement getQuery() :{  GetStatement getStatement = new GetStatement();  GetClause getClause = new GetClause();  InClause inClause = new InClause();  HavingClause havingClause = null;  SortByClause sortByClause = null;}{  getClause = getClause()   inClause = inClause()   [ havingClause = havingClause() ]   [ sortByClause = sortByClause() ]  {    getStatement.setGetClause(getClause);    getStatement.setInClause(inClause);    getStatement.setHavingClause(havingClause);    getStatement.setSortByClause(sortByClause);    return getStatement;  }}GetClause getClause() :{  GetClause getClause = new GetClause();  Expression property = null;
  Token propertyToken = null;
  Expression propertyFunction = null;  Token limit = null;  boolean distinct = false;}{  "GET" [ limit = < S_NUMBER > ]  [    "DISTINCT"    {      distinct = true;    }  ]
  (
    LOOKAHEAD(2)  propertyFunction = functionCall()
	| propertyToken = < S_IDENTIFIER >
	)  {
	if (propertyToken != null)	{
	    property = new Constant(propertyToken != null ? propertyToken.toString() : null, 0);	}
	else
	{		property = propertyFunction;
	}
        getClause.setLimit(limit != null ? limit.toString() : null);    getClause.setDistinct(distinct);    getClause.setProperty(property);    return getClause;  }}InClause inClause() :{  InClause inClause = new InClause();  Vector pathItems = new Vector();  PathItem pathItem;}{  "IN" "(" pathItem = pathItem()  {    pathItems.addElement(pathItem);  }  (    "," pathItem = pathItem()    {      pathItems.addElement(pathItem);    }  )*  ")"  {    inClause.setPathItems(pathItems);    return inClause;  }}HavingClause havingClause() :{  HavingClause havingClause = null;  Expression expression;}{  "HAVING" expression = expression()  {    if (expression != null)    {      havingClause = new HavingClause();      havingClause.setExpression(expression);    }    return havingClause;  }}SortByClause sortByClause() :{  SortByClause sortByClause = new SortByClause();  Token property;  boolean isAscending = true; // default value
}{  "SORT" "BY" property = < S_IDENTIFIER >  [    "ASCENDING"  | "DESCENDING"    {      isAscending = false;    }  ]  {    sortByClause.setProperty(property != null ? property.toString() : null);    sortByClause.setAscendingOrder(isAscending);    return sortByClause;  }}PathItem pathItem() :{  PathItem pathItem = new PathItem();  Token path = null;
  GetStatement subGetStatement = null;  Token deep = null;}{  (    path = < S_CHAR_LITERAL >
	| subGetStatement = subQuery()
  )

  [ "DEEP" deep = < S_NUMBER > ]  {
    if (path != null)    {		pathItem.setPath(new Constant(path.toString().substring(1, path.toString().length() - 1), 3));
    }

    if (subGetStatement != null)    {		pathItem.setPath(subGetStatement);
    }
        pathItem.setDeep(deep != null ? deep.toString() : null);    return pathItem;  }}Expression expression() :{  Expression e1, e2;  ExpressionImpl e = null;  boolean single = true;}{  e1 = andExpression()  (    "OR" e2 = andExpression()    {      if (single)      {        e = new ExpressionImpl("OR", e1);      }      single = false;      e.addOperand(e2);    }  )*  {    return (single ? e1 : e);  }}Expression andExpression() :{  Expression e1, e2;  ExpressionImpl e = null;  boolean single = true;}{  e1 = unaryLogicalExpression()  (    "AND" e2 = unaryLogicalExpression()    {      if (single)      {        e = new ExpressionImpl("AND", e1);      }      single = false;      e.addOperand(e2);    }  )*  {    return (single ? e1 : e);  }}Expression unaryLogicalExpression() :{  Expression e1, e;  boolean not = false;}{  LOOKAHEAD(2)  e = existsClause()  {    return e;  }|  (    [      "NOT"      {        not = true;      }    ]    e1 = relationalExpression()    {      if (not) e = new ExpressionImpl("NOT", e1);      else e = e1;      return e;    }  )}ExpressionImpl existsClause() :{  ExpressionImpl e;  GetStatement q;  boolean not = false;}{  [    "NOT"    {      not = true;    }  ]  "EXISTS" "(" q = subQuery() ")"  {    ExpressionImpl e1 = new ExpressionImpl("EXISTS", q);    if (not) e = new ExpressionImpl("NOT", e1);    else e = e1;    return e;  }}Expression relationalExpression() :{  Expression e1, eleft;  ExpressionImpl eright = null;  Vector v;  boolean prior = false;}{  /* Only after looking past "(", Expression() and "," we will know that
it is expression list */  (    LOOKAHEAD("(" simpleExpression() ",") //)
    "(" v = expressionList() ")"    {      eleft = new ExpressionImpl(",");      ((ExpressionImpl) eleft).setOperands(v);    }  |    (      [        "PRIOR"        {          prior = true;        }      ]      e1 = simpleExpression()      {        if (prior) eleft = new ExpressionImpl("PRIOR", e1);        else eleft = e1;      }    )  ) //Closes parenthese opened before LOOKAHEAD
  /* Lookahead(2) is required because of NOT IN,NOT BETWEEN and NOT LIKE */  (    eright = relationalOperatorExpression()  | LOOKAHEAD(2)    (      eright = inClauseExpression()    )  | LOOKAHEAD(2)    (      eright = betweenClauseExpression()    )  | LOOKAHEAD(2)    (      eright = likeClauseExpression()    )  | LOOKAHEAD(2)    (      eright = matchClauseExpression()    )  )?  {    if (eright == null) return eleft;    Vector v2 = eright.getOperands();    if (v2 == null) v2 = new Vector(); //For IS NULL, which is unary!
    v2.insertElementAt(eleft, 0);    eright.setOperands(v2);    return eright;  }}Vector expressionList() :{  Vector v = new Vector(8);  Expression e;}{  e = simpleExpressionOrPreparedCol()  {    v.addElement(e);  }  (    "," e = simpleExpressionOrPreparedCol()    {      v.addElement(e);    }  )*  {    return v;  }}ExpressionImpl relationalOperatorExpression() :{  ExpressionImpl e;  Expression e1, eright;  String op;  String unaryOp = null;}{  op = Relop()  {    e = new ExpressionImpl(op);  }  /* Only after seeing an ANY/ALL or "(" followed by a SubQuery() we can
determine that is is a sub-query
*/  (    LOOKAHEAD("ANY"  | "ALL"  | "(" "SELECT") //)
    (      [        "ALL"        {          unaryOp = "ALL";        }      | "ANY"        {          unaryOp = "ANY";        }      ]      "(" e1 = subQuery() ")"      {        if (unaryOp == null) eright = e1;        else eright = new ExpressionImpl(unaryOp, e1);      }    )  |    [      "PRIOR"      {        unaryOp = "PRIOR";      }    ]    e1 = simpleExpressionOrPreparedCol()    {      if (unaryOp == null) eright = e1;      else eright = new ExpressionImpl(unaryOp, e1);    }  )  {    e.addOperand(eright);    return e;  }}Expression simpleExpressionOrPreparedCol() :{  Expression e;}{  e = simpleExpression()  {    return e;  }| e = preparedCol()  {    return e;  } // For prepared columns ("?")
| e = subQuery()  {    return e;  }}// For prepared columns ("?")
Expression preparedCol() :{}{  "?"  {    return new ExpressionImpl("?");  } // For prepared columns ("?")
}ExpressionImpl inClauseExpression() :{  ExpressionImpl e;  GetStatement q = null;  boolean not = false;  Vector v = null;}{  [    "NOT"    {      not = true;    }  ]  "IN"  {    e = new ExpressionImpl(not ? "NOT IN" : "IN");  }  "("  (
    LOOKAHEAD(2)     v = expressionList()    {      e.setOperands(v);    }  | q = subQuery()    {      e.addOperand(q);    }  )  ")"  {    return e;  }}ExpressionImpl betweenClauseExpression() :{  ExpressionImpl e;  Expression e1, e2;  boolean not = false;}{  [    "NOT"    {      not = true;    }  ]  "BETWEEN" e1 = simpleExpressionOrPreparedCol() "AND" e2 = simpleExpressionOrPreparedCol()  {    if (not) e = new ExpressionImpl("NOT BETWEEN", e1, e2);    else e = new ExpressionImpl("BETWEEN", e1, e2);    return e;  }}ExpressionImpl likeClauseExpression() :{  Expression eright;  ExpressionImpl e;  boolean not = false;}{  [    "NOT"    {      not = true;    }  ]  "LIKE" eright = simpleExpressionOrPreparedCol()  {    if (not) e = new ExpressionImpl("NOT LIKE", eright);    else e = new ExpressionImpl("LIKE", eright);    return e;  }}ExpressionImpl matchClauseExpression() :{  Expression eright;  ExpressionImpl e;  boolean not = false;}{  [    "NOT"    {      not = true;    }  ]  "MATCH" eright = simpleExpressionOrPreparedCol()  {    if (not) e = new ExpressionImpl("NOT MATCH", eright);    else e = new ExpressionImpl("MATCH", eright);    return e;  }}Expression simpleExpression() :{  Token op;  Expression e1, e2;  ExpressionImpl e = null;}{  e1 = multiplicativeExpression()  (    (      op = "+"    | op = "-"    | op = "||"    )    e2 = multiplicativeExpression()    {      e = new ExpressionImpl(op.toString(), e1);      e.addOperand(e2);      e1 = e;    }  )*  {    return e1;  }}Expression multiplicativeExpression() :{  Token op;  Expression e1, e2;  ExpressionImpl e = null;}{  e1 = expotentExpression()  (    (      op = "*"    | op = "/"    )    e2 = expotentExpression()    {      e = new ExpressionImpl(op.toString(), e1);      e.addOperand(e2);      e1 = e;    }  )*  {    return e1;  }}Expression expotentExpression() :{  Token op;  Expression e1, e2;  ExpressionImpl e = null;  boolean single = true;}{  e1 = unaryExpression()  (    op = "**" e2 = unaryExpression()    {      if (single) e = new ExpressionImpl(op.toString(), e1);      single = false;      e.addOperand(e2);    }  )*  {    return (single ? e1 : e);  }}Expression unaryExpression() :{  Token op = null;  Expression e1, e;}{  [    op = "+"  | op = "-"  ]  e1 = primaryExpression()  {    if (op == null) e = e1;    else e = new ExpressionImpl(op.toString(), e1);    return e;  }}// 01/07/00 PY.Gibello - Added COUNT(*) to SQLPrimaryExpression
// TBD should be ZConstant("COUNT(*)", ZConstant.STRING))
// instead of ZConstant("*", ZConstant.COLUMNNAME) ??
// 01/06/02 PY.Gibello - Added ALL | DISTINCT (then the column name
// starts with "all " or "distinct " when required, which may not be the
// fairest solution...)
// SQLPrimaryExpression ::= NULL | OuterJoinExpression
// | AggregateFunc ( [ ALL | DISTINCT ] TableColumn ) | TableColumn
// | COUNT(*)
// | <NUMBER> | <STRING> | <BIND>
Expression primaryExpression() :{  Token t;  String s, s2, modifier = "";  Expression e;}{  "NULL"  {    return new Constant("NULL", Constant.NULL);  }| LOOKAHEAD(outerJoinExpression())  s = outerJoinExpression()  {    return new Constant(s, Constant.COLUMNNAME);    //return new ExpressionImpl("_NOT_SUPPORTED"); //TBD
  }| LOOKAHEAD(3)  "COUNT" "(" "*" ")"  {    return new ExpressionImpl("COUNT", new Constant("*", Constant.COLUMNNAME));  }| LOOKAHEAD(3)  s = aggregateFunc() "("  (    "ALL"    {      modifier = "all ";    }  | "DISTINCT"    {      modifier = "distinct ";    }  )  s2 = tableColumn() ")"  {    return new ExpressionImpl(s, new Constant(modifier + s2, Constant.COLUMNNAME));  }| LOOKAHEAD(2)  e = functionCall()  {    return e;  }  /*
| LOOKAHEAD(<S_IDENTIFIER> "(") e = FunctionCall() { return e; }
*/| s = tableColumn()  {    return new Constant(s, Constant.COLUMNNAME);  }| t = < S_NUMBER >  {    return new Constant(t.toString(), Constant.NUMBER);  }| t = < S_CHAR_LITERAL >  {    s = t.toString();    if (s.startsWith("\'")) s = s.substring(1);    if (s.endsWith("\'")) s = s.substring(0, s.length() - 1);    return new Constant(s, Constant.STRING);  }| t = < S_BIND >  {    return new Constant(t.toString(), Constant.STRING);  }| "(" e = expression() ")"  {    return e;  }}// AggregateFunc ::= SUM | AVG | MAX | MIN | COUNT
// 01/07/00 PY.Gibello - Added COUNT
String aggregateFunc() :{  Token t;}{  t = "SUM"  {    return t.toString();  }| t = "AVG"  {    return t.toString();  }| t = "MAX"  {    return t.toString();  }| t = "MIN"  {    return t.toString();  }| t = "COUNT"  {    return t.toString();  }}Expression functionCall() :{  Token t;  String s;  Expression e;  Vector parm = null;}{  (    t = < S_IDENTIFIER >    {      s = t.toString();    }  | s = aggregateFunc()  )  "(" [ parm = expressionList() ] ")"  {    int nparm = Utils.isCustomFunction(s);    if (nparm < 0) nparm = (Utils.isAggregate(s) ? 1 : - 1);    if (nparm < 0) throw new ParseException("Undefined function: " + s);    if (nparm != Utils.VARIABLE_PLIST && nparm > 0)    {      if (parm == null || parm.size() != nparm) throw new ParseException("Function " + s + " should have " + nparm + " parameter(s)");    }
    Function f = new Function();
    f.setName(s);
    f.setParams(parm);
    f.setAggregate(Utils.isAggregate(s));    return f;  }}String outerJoinExpression() :{  String s = null;  String c = "";}{  // user.table.col
  s = oracleObjectName()  [    "." c = oracleObjectName()    {      s += "." + c;    }    [      "." c = oracleObjectName()      {        s += "." + c;      }    ]  ]  "(" "+" ")"  {    return s + "(+)";  }}GetStatement subQuery() :{  GetStatement q;}{  q = getQuery()  {    return q;  }}String Relop() :{  Token op;}{  op = "="  {    return op.toString();  }| op = "<>"  {    return op.toString();  }| op = ">"  {    return op.toString();  }| op = ">="  {    return op.toString();  }| op = "<"  {    return op.toString();  }| op = "<="  {    return op.toString();  }}String tableColumn() :{  StringBuffer buf = new StringBuffer();  String s;}{  // user.table.column
  s = oracleObjectName()  {    buf.append(s);  }  [    "." s = oracleObjectName()    {      buf.append("." + s);    }    [      "." s = oracleObjectName()      {        buf.append("." + s);      }    ]  ]  {    return buf.toString();  }}String oracleObjectName() :{  Token t;}{  t = < S_IDENTIFIER >  {    return t.toString();  }| t = < S_QUOTED_IDENTIFIER >  {    return t.toString();  }}
